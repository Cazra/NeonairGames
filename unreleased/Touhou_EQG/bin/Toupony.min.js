/** 
 * An API for formatting the date and time.
 */
Util.DateTime = {
  
  MILLIS_PER_MINUTE: 60000,
  
  _monthStrsShort: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  
  /** 
   * Returns a formatted date-time string for a Date object. 
   * @return {string}
   */
  getFormattedDateTime: function(date) {
    var month = date.getMonth();
    var date = date.getDate();
    var year = date.getFullYear();    
    
    var hours = date.getHours();
    var minutes = date.getMinutes();
    
    var dateStr = this._formatDateString(month, date, year);
    var timeStr = this._formatTimeString(hours, minutes);
    return dateStr + " - " + timeStr;
  },
  
  
  _formatDateString: function(month, date, year) {
    var monthStr = this.monthToShortString(month);
    return monthStr + " " + date + ", " + year;
  },
  
  
  _formatTimeString: function(hours, minutes) {
    var ampm = "AM";
    if(hours > 12) {
      hours -= 12;
      ampm = "PM";
    }
    return hours + ":" + minutes + " " + ampm;
  },
  
  
  /** 
   * Converts a month numerical value to a 3-letter string for the month. 
   * E.g. 1 -> "Jan", 2 -> "Feb", etc.
   * @param {int} monthNum
   */
  monthToShortString: function(monthNum) {
    if(monthNum >= 1 && monthNum <= 12) {
      return this._monthStrsShort[monthNum];
    }
    else {
      throw new Error("Invalid month value: " + monthNum);
    }
  }
  
};
/**
 * Some JSON utilities.
 */
Util.JSON = {
  
  /** 
   * Produces a deep copy of a JSON object.
   * @param {object} jObj
   * @return {object}
   */
  clone: function(jObj) {
    var jStr = JSON.stringify(jObj);
    return JSON.parse(jStr);
  }
}


/** 
 * Application and namespace for the Equestria Girls Touhou project.
 * @constructor
 * @param {div element} container
 */
var Toupony = function(container) {
  TentaGL.Application.call(this, container, {stencil:true, alpha: false});
  
  // TODO: Initialize global variables from localStorage.
};


Toupony.MAX_LIVES = 7;
Toupony.MAX_BOMBS = 7;

/** 
 * The game's width.
 */
Toupony.WIDTH = 640;

/** 
 * The game's height.
 */
Toupony.HEIGHT = 480;

/** 
 * The width of the danmaku play area.
 */
Toupony.STAGE_WIDTH = 400;

/** 
 * The height of the danmaku play area.
 */
Toupony.STAGE_HEIGHT = 448;

/** 
 * X offset of the danmaku play area from the left edge of the screen. 
 */
Toupony.STAGE_X = 32;

/** 
 * Y offset of the danmaku play area from the top edge of the screen.
 */
Toupony.STAGE_Y = 16;

/** 
 * Returns the main purple-border font for the game.
 * @return {TentaGL.BlitteredFont}
 */
Toupony.getFont = function() {
  if(!Toupony._font) {
    Toupony._font = TentaGL.BlitteredFont.fromURL("img/menu/font.png", false, [50, 56], [0, 4], 0);
  }
  return Toupony._font;
};

/** 
 * Returns the player dialog blue-border font for the game.
 * @return {TentaGL.BlitteredFont}
 */
Toupony.getPlayerFont = function() {
  if(!Toupony._fontPlayer) {
    Toupony._fontPlayer = TentaGL.BlitteredFont.fromURL("img/menu/fontPlayer.png", false, [50, 56], [0, 4], 0);
  }
  return Toupony._fontPlayer;
};

/** 
 * Returns the enemy dialog red-border font for the game.
 * @return {TentaGL.BlitteredFont}
 */
Toupony.getEnemyFont = function() {
  if(!Toupony._fontEnemy) {
    Toupony._fontEnemy = TentaGL.BlitteredFont.fromURL("img/menu/fontEnemy.png", false, [50, 56], [0, 4], 0);
  }
  return Toupony._fontEnemy;
};

Toupony.prototype = {
  
  constructor: Toupony,
  
  /** 
   * Returns the GameConfig object containing the game's save data.
   * @return {Toupony.GameConfig}
   */
  getGameData: function() {
    return this._config;
  },
  
  /** 
   * Loads game data from local storage.
   */
  loadGameData: function() {
    var gameConfigStr = localStorage.getItem("Toupony");
    if(gameConfigStr) {
      try {
        var gameConfig = JSON.parse(gameConfigStr);
        this._config = Toupony.GameConfig.fromJSON(gameConfig);
      }
      catch(err) {
        console.log("Error loading saved game data. Loading default settings instead.", err);
        this._config = new Toupony.GameConfig();
      }
    }
    else {
      this._config = new Toupony.GameConfig();
    }
  },
  
  /** 
   * Saves game data from local storage.
   */
  saveGameData: function() {
    var gameConfig = this._config.toJSON();
    var gameConfigStr = JSON.stringify(gameConfig);
    localStorage.setItem("Toupony", gameConfigStr);
  },
  
  
  
  /** 
   * Returns the game's 2D camera.
   * @return {TentaGL.Camera2D}
   */
  getCamera2D: function() {
    if(!this._cam2D) {
      this._cam2D = new TentaGL.Camera2D([0, 0], 
                                        Toupony.WIDTH, Toupony.HEIGHT, 
                                        true);
      this._cam2D.anchor([0,0]);
    }
    return this._cam2D;
  },
  
  
  /** 
   * Returns the main blittered font for the game.
   * @return {TentaGL.BlitteredFont}
   */
  getFont: function() {
    return this._font;
  },
  
  
  //////// TentaGL.Application implementations
  
  initShaders: function(gl) {
    TentaGL.SimpleShader.load(gl, "simple");
    TentaGL.PhongShader.load(gl, "phong");
    TentaGL.NormalShader.load(gl, "normal");
    TentaGL.GradientShader.load(gl, "gradient");
    TentaGL.PlaneSimpleShader.load(gl, "plane");
    TentaGL.CircleShader.load(gl, "circle");
    
    Toupony.AddColorShader.load(gl, "addColor");
  },
  
  initMaterials: function(gl) {
    TentaGL.MaterialLib.add(gl, "red", TentaGL.Color.RED);
  },
  
  
  initModels: function(gl) {
  
  },
  
  
  
  reset: function(gl) {
    this.loadGameData();
    // TODO: Go to title level
    
    var difficulty = Toupony.Difficulty.NORMAL;
    var team = Toupony.PlayerTeams.TWI_RARE;
    var mode = new Toupony.NormalMode(difficulty, team);
    
    var mainLevel = new Toupony.MainLevel(this, mode);
    this.setLevel(mainLevel);
  },
  
  
  update: function(gl) {
    if(TentaGL.ShaderLoader.isLoading()) {
      console.log("Loading shaders..." + TentaGL.ShaderLoader.getNumLoading());
      return;
    }
    if(TentaGL.ImageLoader.isLoading()) {
      console.log("Loading image data...");
      return;
    }
    if(TentaGL.Model.ObjReader.isLoading()) {
      console.log("Loading models..." + TentaGL.Model.ObjReader.getNumLoading());
      return;
    }
    if(TentaGL.AudioLoader.isLoading()) {
      console.log("Loading audio data...");
      return;
    }
    
    this.getLevelManager().run(gl);
  }
  
};


Util.Inheritance.inherit(Toupony, TentaGL.Application);

Toupony.main = function() {
  var container = document.getElementById("TouponyContainer");
  (new Toupony(container)).start();
};
/** 
 * Base class for background scenes. Backgrounds are rendered to an offscreen 
 * buffer so that a uniform opacity can be applied to the entire background
 * for smooth transitions between backgrounds.
 * @abstract
 * @constructor
 * @param {Toupony.Stage} stage
 */
Toupony.Background = function(stage) {
  this._stage;
  
  this._opacity = 1;
  this._buffer = new TentaGL.BufferTexture(stage.getApp().getGL(), Toupony.STAGE_WIDTH, Toupony.STAGE_HEIGHT);
};


/** 
 * Gets the camera used to render the background scene onto a sprite. 
 */
Toupony.Background.getCamera2D = function() {
  if(Toupony.Background._cam2D === undefined) {
    Toupony.Background._cam2D = new TentaGL.Camera2D([0,0], Toupony.STAGE_WIDTH, Toupony.STAGE_HEIGHT, true);
  }
  return Toupony.Background._cam2D;
};


Toupony.Background.prototype = {
  
  constructor: Toupony.Background,
  
  
  /** 
   * Returns the stage this background is used for. 
   * @return {Toupony.Stage}
   */
  getStage: function() {
    return this._stage;
  },
  
  
  
  /** 
   * Setter/getter for the opacity of the background. 
   * @param {float} opacity   Optional.
   * @return {float}
   */
  opacity: function(opacity) {
    if(opacity !== undefined) {
      this._opacity = opacity;
    }
    return this._opacity;
  },
  
  
  
  /** 
   * Renders the background. 
   * @param {WebGLRenderingContext} gl
   */
  render: function(gl) {
    this._buffer.renderToMe(gl, this.draw.bind(this));
    
    TentaGL.ShaderLib.use(gl, "simple");
    TentaGL.RenderMode.set2D(gl);
    var aspect = Toupony.STAGE_WIDTH/Toupony.STAGE_HEIGHT;
    TentaGL.ViewTrans.setCamera(gl, Toupony.Background.getCamera2D(), aspect);
    this._buffer.useMe(gl);
    
    TentaGL.ShaderLib.current(gl).setOpacity(gl, this._opacity);
    
    TentaGL.ViewTrans.push(gl);
    
    TentaGL.ViewTrans.scale(gl, [Toupony.STAGE_WIDTH, Toupony.STAGE_HEIGHT]);
    TentaGL.ModelLib.render(gl, "unitSprite");
    
    TentaGL.ViewTrans.pop(gl);
  },
  
  
};

/** 
 * The game's configurable data.
 * The constructor sets the data up with default values,
 * as thought the user has never played the game before.
 * @constructor
 */
Toupony.GameConfig = function() {
  this.startLives(3);
  this.startBombs(3);
  this.extraUnlocked(false);
  
  this._highScores = new Toupony.HighScoresRecords();
  this._spellCards = {}; // TODO new Toupony.SpellCardRecords();
  this._achievements = {}; // TODO new Toupony.AchievementRecords();
};


/** 
 * Produces a GameConfig from a json object representation. 
 * @param {object} jObj
 * @return {Toupony.GameConfig}
 */
Toupony.GameConfig.fromJSON = function(jObj) {
  this.startLives(jObj.startLives);
  this.startBombs(jObj.startBombs);
  this.extraUnlocked(jObj.extraUnlocked);
  
  this._highScores = Toupony.HighScoresRecords.fromJSON(jObj.highScores);
  this._spellCards = {}; // TODO new Toupony.SpellCardRecords(jObj.spellCards);
  this._achievements = {}; // TODO new Toupony.AchievementRecords(jObj.achievements);
};


Toupony.GameConfig.prototype = {
  
  constructor: Toupony.GameConfig,
  
  isaGameConfig: true,
  
  
  
  /** 
   * Setter/getter for the starting number of lives. 
   * @param {uint} n    Optional
   * @return {uint}
   */
  startLives: function(n) {
    if(n !== undefined) {
      this._startLives = Math.max(0, Math.min(n, Toupony.MAX_LIVES));
    }
    return this._startLives;
  },
  
  
  /** 
   * Setter/getter for the starting number of lives. 
   * @param {uint} n    Optional.
   * @return {uint}
   */
  startBombs: function(n) {
    if(n !== undefined) {
      this._startBombs = Math.max(0, Math.min(n, Toupony.MAX_BOMBS));
    }
    return this._startBombs;
  },
  
  /** 
   * Setter/getter for whether the extra stage has been 
   * unlocked.
   * @param {boolean} flag    Optional.
   * @return {boolean}
   */
  extraUnlocked: function(flag) {
    if(flag !== undefined) {
      this._extraUnlocked = flag;
    }
    return this._ExtraUnlocked;
  },
  
  
  /** 
   * Returns the highscores table for the specified difficulty and team. 
   * @param {enum: Toupony.Difficulty} dif
   * @param {enum: Toupony.PlayerTeams} team
   * @return {Toupony.HighScoresTable}
   */
  getHighScoresTable: function(dif, team) {
    return this._highScores.getTable(dif, team);
  },
  
  
  /** 
   * Returns the value of the highest score for the specified difficulty and
   * team. If there is no high score, 0 is returned.
   * @param {enum: Toupony.Difficulty} dif
   * @param {enum: Toupony.PlayerTeams} team
   * @return {int}
   */
  getHighestScore: function(dif, team) {
    var table = this.getHighScoresTable(dif, team);
    if(table.getCount() > 0) {
      return table.getHighScore(0).getScore();
    }
    else {
      return 0;
    }
  },
  
  
  /** 
   * Produces a JSON representation of the configurations.
   * @return {object}
   */
  toJSON: function() {
    var startLives = this._startLives;
    var startBombs = this._startBombs;
    var extraUnlocked = this._extraUnlocked;
    var highScores = this._highScores;
    var spellCardRecords = this._spellCardRecords;
    var achievements = this._achievements;
  }
};
/** 
 * An enumeration of difficulty levels for the game.
 */
Toupony.Difficulty = {
  
  EASY: 1,
  NORMAL: 2,
  HARD: 3,
  LUNATIC: 4,
  EXTRA: 5,
};
/** 
 * An enumeration for the gameplay modes.
 */
Toupony.GameModes = {
  NORMAL: 1,
  STAGE_PRACTICE: 2
};
/** 
 * An enumeration for the playable player teams, and a factory for instances of 
 * player team sprites.
 */
Toupony.PlayerTeams = {
  TWI_RARE: 1,
  DASH_PIE: 2,
  FLUTTER_JACK: 3,
  DERPY: 4,
  SUNSET_SHIMMER: 5,
  MAUDE_PIE: 6
  
};
/** 
 * An enumeration for stage progress during gameplay.
 */
Toupony.StageProgress = {
  STAGE_1: 1,
  STAGE_2: 2,
  STAGE_3: 3,
  STAGE_4: 4,
  STAGE_5: 5,
  STAGE_6: 6,
  CLEAR: 7,
  ZERO_CONTINUE_CLEAR: 8,
  EXTRA: 9,
  EXTRA_CLEAR: 10
};
/**
 * The main gameplay level, providing the context for our game.
 * @constructor
 * @param {Toupony} app
 * @param {Toupony.GameplayMode} mode
 */
Toupony.MainLevel = function(app, mode) {
  TentaGL.Level.call(this, app);
  this._mode = mode;
};


Toupony.MainLevel.prototype = {
  
  constructor: Toupony.MainLevel,
  
  /** 
   * Returns the gameplay settings.
   * @return {Toupony.GameplayMode}
   */
  getMode: function() {
    return this._mode;
  },
  
  /** 
   * Returns the object containing the game's configurations and saved data.
   * @return {Toupony.GameConfig}
   */
  getConfig: function() {
    return this._app.getGameData();
  },
  
  /** 
   * Returns the player team code.
   * @return {enum: Toupony.PlayerTeams}
   */
  getTeam: function() {
    return this._mode.getTeam();
  },
  
  /** 
   * Returns the gameplay difficulty.
   * @return {enum: Toupony.Difficulty}
   */
  getDifficulty: function() {
    return this._mode.getDifficulty();
  },
  
  
  /** 
   * Returns the player. 
   * @return {Toupony.Player}
   */
  getPlayer: function() {
    return this._player;
  },
  
  
  /** 
   * Returns the player's stats.
   * @return {Toupony.PlayerStats}
   */
  getPlayerStats: function() {
    return this._player.getStats();
  },
  
  
  /** 
   * Returns the high score to be displayed in the HUD. 
   * @return {uint}
   */
  getHighScore: function() {
    var difficulty = this.getDifficulty();
    var team = this.getTeam();
    var config = this.getConfig();
    var highScore = config.getHighestScore(difficulty, team);
    
    return Math.max(highScore, this.getPlayerStats().score());
  },
  
  
  
  /**
   * @inheritDoc TentaGL.Level
   */
  clean: function(gl) {
    Toupony.MainHUD.clean(gl);
    Toupony.Player.clean(gl);
    Toupony.TwiPlayer.clean(gl);
    Toupony.EnemyBullet.clean(gl);
  },
  
  
  /**
   * @inheritDoc TentaGL.Level
   */
  reset: function(gl) {
    this._loadResources(gl);
    
    this._initHUD();
    this._initStage();
    this._initPlayer();
    this._initSpriteGroups();
    
    this._paused = false;
    
    
    this._enemies.add(new TentaGL.Sprite([100, 100]));
    this._enemies.add(new TentaGL.Sprite([200, 200]));
    this._enemies.add(new TentaGL.Sprite([300, 100]));
  },
  
  
  /** 
   * Loads graphics and other resources for the level.
   */
  _loadResources: function(gl) {
    Toupony.MainHUD.load(gl);
    Toupony.Player.load(gl);
    Toupony.TwiPlayer.load(gl);
    Toupony.EnemyBullet.load(gl);
  },
  
  /** 
   * Initializes the HUD for our gameplay mode. 
   */
  _initHUD: function() {
    this._hud = new Toupony.MainHUD(this._mode);
  },
  
  
  /** 
   * Initializes the stage to be the starting stage for our gameplay mode.
   */
  _initStage: function() {
    this._stage = this._mode.getStartStage();
  },
  
  
  /** 
   * Creates the player sprite based on the user's gameplay specifications.
   */
  _initPlayer: function() {
    var config = this.getConfig();
    var mode = this.getMode();
    
    this._player = Toupony.PlayerFactory.createPlayer(config, mode);
    this._player.xyz([Toupony.STAGE_WIDTH*0.5, Toupony.STAGE_HEIGHT*0.8, 0]);
  },
  
  /** 
   * Initializes the various sprite groups managed by the game context.
   */
  _initSpriteGroups: function() {
    this._enemies = new Toupony.SpriteGroup();
    this._playerBullets = new Toupony.SpriteGroup();
    this._enemyBullets = new Toupony.SpriteGroup();
    this._items = new Toupony.SpriteGroup();
    this._sfx = new Toupony.SpriteGroup();
  },
  
  
  /** 
   * Returns the SpriteGroup for the player's bullets.
   * @return {Toupony.SpriteGroup}
   */
  getPlayerBullets: function() {
    return this._playerBullets;
  },
  
  /** 
   * Returns the SpriteGroup for the enemies.
   * @return {Toupony.SpriteGroup}
   */
  getEnemies: function() {
    return this._enemies;
  },
  
  /** 
   * Returns the SpriteGroup for the enemy bullets.
   * @return {Toupony.SpriteGroup}
   */
  getEnemyBullets: function() {
    return this._enemyBullets;
  },
  
  /** 
   * Returns the SpriteGroup for the items.
   * @return {Toupony.SpriteGroup}
   */
  getItems: function() {
    return this._items;
  },
  
  /** 
   * Returns the SpriteGroup for the special effects.
   * @return {Toupony.SpriteGroup}
   */
  getSpecialFX: function() {
    return this._sfx;
  },
  
  
  
  /** 
   * @inheritDoc TentaGL.Level
   */
  update: function(gl) {
    
    var keyboard = this.keyboard();
    var context = this;
    
    Toupony.Cheats.run(keyboard, context);
    
    if(this._paused) {
      // TODO: run pause menu.
    }
    else {
      this._stage.run(context);
      this._player.control(keyboard, context);
      
      // Move all the other sprites. 
      this._playerBullets.forEach(function(bullet) {
        bullet.move(context);
      });
      
      // TODO: handle collisions.
      
      this._animateEverything();
    }
  },
  
  _animateEverything: function() {
    this._player.animate();
    
    this._enemies.animate();
    this._enemyBullets.animate();
    this._playerBullets.animate();
    this._items.animate();
    this._sfx.animate();
  },
  
  
  /** 
   * @inheritDoc TentaGL.Level
   */
  render: function(gl) {
    var self = this;
    var aspect = gl.canvas.width/gl.canvas.height;
    
    TentaGL.clear(gl, new TentaGL.Color([0.1, 0.1, 0.3, 1]));
    
    TentaGL.ShaderLib.use(gl, "simple");
    TentaGL.ViewTrans.setCamera(gl, this.getApp().getCamera2D(), aspect);
    TentaGL.RenderMode.set2D(gl);
    
    this._renderPlayfieldContent(gl);
    
    this._hud.renderWithStats(gl, this.getPlayerStats(), this.getHighScore());
  },
  
  
  /** 
   * Renders all objects in the playable area. 
   * @param {WebGLRenderingContext} gl
   */
  _renderPlayfieldContent: function(gl) {
    TentaGL.ViewTrans.push(gl);
    TentaGL.ViewTrans.translate(gl, [Toupony.STAGE_X, Toupony.STAGE_Y]);
    
    // Render stage's current background.
    // this._stage.renderBackground(gl);
    
    Toupony.getPlayerFont().renderString(gl, 
      " !\"#$%&'()*+,-./\n" +
      "0123456789:;<=>?\n" +
      "@ABCDEFGHIJKLMNO\n" +
      "PQRTSUVWXYZ[\\]^_\n" +
      "`abcdefghijklmno\n" +
      "pqrstuvwxyz{|}~",
      [0,0], true, 28
    );
    
    this._player.render(gl);
    
    this._enemies.render(gl);
    this._enemyBullets.render(gl);
    this._playerBullets.render(gl);
    this._items.render(gl);
    this._sfx.render(gl);
    
    TentaGL.ViewTrans.pop(gl);
  }
  
  
};


Util.Inheritance.inherit(Toupony.MainLevel, TentaGL.Level);


/** 
 * The HUD for the MainLevel, displaying the player's score, lives, etc..
 * @param {Toupony.GameplayMode} mode
 */
Toupony.MainHUD = function(mode) {
  this._mode = mode;
};


/** 
 * Unloads the object's GL memory resources.
 * @param {WebGLRenderingContext} gl
 */
Toupony.MainHUD.clean = function(gl) {
  TentaGL.MaterialLib.remove(gl, "mainHUD");
};


/** 
 * Loads the object's GL memory resources.
 * @param {WebGLRenderingContext} gl
 */
Toupony.MainHUD.load = function(gl) {
  TentaGL.MaterialLib.add(gl, "mainHUD", TentaGL.Texture.fromURL(gl, "img/menu/mainHUD.png"));
};


Toupony.MainHUD.prototype = {
  
  constructor: Toupony.MainHUD,
  
  /** 
   * Renders the player's stats.
   * @param {WebGLRenderingContext} gl
   * @param {PlayerStats} stats
   */
  renderWithStats: function(gl, stats, highScore) {
    this._setShaderOpaque(gl);
    
    this._renderBackdrop(gl);
    
    var highScoreStr = this._padString("" + highScore, "0", 8);
    var scoreStr = this._padString("" + stats.score(), "0", 8);
    var powerStr = stats.power().toFixed(1);
    var grazeStr = "" + stats.graze();
    
    this._renderHUDString(gl, highScoreStr, [520,45]);
    this._renderHUDString(gl, scoreStr, [520,75]);
    this._renderHUDString(gl, powerStr, [520,175]);
    this._renderHUDString(gl, grazeStr, [520,205]);
  },
  
  
  _setShaderOpaque: function(gl) {
    var program = TentaGL.ShaderLib.current(gl);
    if(program.setOpacity) {
      program.setOpacity(gl, 1.0);
    }
  },
  
  
  /** 
   * Renders the HUD backdrop.
   * @param {WebGLRenderingContext} gl
   */
  _renderBackdrop: function(gl) {
    TentaGL.ViewTrans.push(gl);
    
    TentaGL.MaterialLib.use(gl, "mainHUD");
    TentaGL.ViewTrans.scale(gl, [640, 480]);
    TentaGL.ModelLib.render(gl, "unitSprite");
    
    TentaGL.ViewTrans.pop(gl);
  },
  
  /** 
   * Pads a string with a character until it is the desired length.
   * @param {string} text
   * @param {char} padChar
   * @param {uint} length
   * @return {string}
   */
  _padString: function(text, padChar, length) {
    while(text.length < length) {
      text = padChar + text;
    }
    return text;
  },
  
  
  /**
   * Renders a string for something in the HUD.
   * @param {WebGLRenderingContext} gl
   * @param {string} text
   * @param {vec2} xy
   */
  _renderHUDString: function(gl, text, xy) {
    var font = Toupony.getFont();
    var fontHeight = 30;
    font.renderString(gl, text, xy, true, fontHeight);
  }
  
};


Util.Inheritance.inherit(Toupony.MainHUD, TentaGL.Renderable);
/** 
 * Base class for various gameplay modes.
 * @abstract
 * @constructor
 * @param {enum: Toupony.Difficulty} difficulty
 * @param {enum: Toupony.PlayerTeams} team
 */
Toupony.GameplayMode = function(difficulty, team) {
  this._difficulty = difficulty;
  this._team = team;
};

Toupony.GameplayMode.prototype = {
  
  constructor: Toupony.GameplayMode,
  
  isaGameplayMode: true,
  
  
  /** 
   * Returns the difficulty set for this gameplay mode.
   * @return {enum: Toupony.Difficulty}
   */
  getDifficulty: function() {
    return this._difficulty;
  },
  
  
  /** 
   * Returns the player team code.
   * @return {enum: Toupony.PlayerTeams}
   */
  getTeam: function() {
    return this._team;
  },
  
  
  /** 
   * Returns the starting lives for this gameplay mode, or -1 to use the default
   * starting lives value from the game's configurations.
   * @return {int}
   */
  getStartLives: function() {},
  
  
  /** 
   * Returns the starting bombs for this gameplay mode, or -1 to use the default
   * starting bombs value from the game's configurations.
   * @return {int}
   */
  getStartBombs: function() {},
  
  
  /** 
   * Returns the starting stage for this gameplay mode. 
   * @return {Toupony.Stage}
   */
  getStartStage: function() {},
  
  
  /** 
   * Whether this mode allows the player to use continues.
   * @return {boolean}
   */
  continuesAllowed: function() {}
};

/** 
 * The gameplay mode for playing the extra stage. 
 */
Toupony.ExtraMode = function(team) {
  Toupony.GameplayMode.call(this, Toupony.Difficulty.EXTRA, team);
};

Toupony.ExtraMode.prototype = {
  constructor: Toupony.ExtraMode,
  
  isaExtraMode: true,
  
  
  getStartLives: function() {
    return 3;
  },
  
  
  getStartBombs: function() {
    return 3;
  },
  
  
  getStartStage: function() {
    return Toupony.Stages.ExtraStage();
  },
  
  
  continuesAllowed: function() {
    return false;
  }
  
};

Util.Inheritance.inherit(Toupony.ExtraMode, Toupony.GameplayMode);
/** 
 * Normal gameplay mode - nothing special here. We're doing a completely normal 
 * run through the game, stages 1-6 with no special rules.
 */
Toupony.NormalMode = function(difficulty, team) {
  Toupony.GameplayMode.call(this, difficulty, team);
};

Toupony.NormalMode.prototype = {
  constructor: Toupony.NormalMode,
  
  isaNormalMode: true,
    
  getStartLives: function() {
    return -1;
  },

  getStartBombs: function() {
    return -1;
  },
  
  /** 
   * Normal gameplay starts at stage 1. 
   */
  getStartStage: function() {
    return new Toupony.Stage(); // TODO new Toupony.Stage1();
  },
  
  /** 
   * The player is allowed to use continues in normal gameplay.
   */
  continuesAllowed: function() {
    return true;
  }
};

Util.Inheritance.inherit(Toupony.NormalMode, Toupony.GameplayMode);
/** 
 * The gameplay mode for practicing a single stage. 
 * @constructor
 * @param {enum: Toupony.Difficulty} difficulty
 * @param {enum: Toupony.PlayerTeams} team
 * @param {Toupony.Stage} stage
 */
Toupony.StagePracticeMode = function(difficulty, team, stage) {
  Toupony.GameplayMode.call(this, difficulty, team);
  this._stage = stage;
};

Toupony.StagePracticeMode.prototype = {
  constructor: Toupony.StagePracticeMode,
  
  isaStagePracticeMode: true,
  
  getStartLives: function() {
    return Toupony.MAX_LIVES;
  },
  
  getStartBombs: function() {
    return 3;
  },
  
  getStartStage: function() {
    return this._stage;
  }
  
};

Util.Inheritance.inherit(Toupony.StagePracticeMode, Toupony.GameplayMode);
/**
 * Base class for 2D sprite movement patterns. For these movements, we assume
 * a traditional 2D graphics system where the positive Y axis points down.
 * @constructor
 */
Toupony.Movement = function() {};

Toupony.Movement.prototype = {
  
  constructor: Toupony.Movement,
  
  isaMovement: true,
  
  
  
  
  /** 
   * Moves a sprite with this movement.
   * @abstract
   * @param {TentaGL.Sprite} sprite   The sprite being moved.
   * @param {object} context          Some object providing context to the 
   *                                  sprite's environment. E.G. The Level 
   *                                  containing it.
   * @return {vec2} The velocity for the frame of movement.
   */
  move: function(sprite, context) {}
};
/**
 * Moves a sprite at a constant velocity. 
 * The sprite is destroyed if it goes too far offscreen.
 * @constructor
 * @param {float} angle   The angle indicating the direction of the 
 *                            movement, in radians. 
 * @param {float} speed   The magnitude of the movement.
 */
Toupony.LinearMovement = function(angle, speed) {
  this._angle = angle;
  this._speed = speed;
  this._calcVector();
};


Toupony.LinearMovement.fromVector = function(v) {
  var movement = new Toupony.LinearMovement(0, 0);
  movement.vector(v);
  return movement;
};


Toupony.LinearMovement.prototype = {
  
  constructor: Toupony.LinearMovement,
  
  isaLinearMovement: true,
  
  /** 
   * Setter/getter for the angle of the movement, in radians.
   * @param {number} angle  (optional)
   * @return {number}
   */
  angle: function(angle) {
    if(angle !== undefined) {
      this._angle = angle;
      this._calcVector();
    }
    return this._angle;
  },
  
  /** 
   * Recalculates the 2D velocity for this movement from its angle and speed.
   */
  _calcVector: function() {
    var dx = this._speed * Math.cos(this._angle);
    var dy = -this._speed * Math.sin(this._angle);
    this._vector = [dx, dy];
  },
  
  
  /** 
   * Setter/getter for the speed of this movement. 
   * @param {number} speed    (optional)
   * @return {number}
   */
  speed: function(speed) {
    if(speed !== undefined) {
      this._speed = speed;
      this._calcVector();
    }
    return this._speed;
  },
  
  
  /** 
   * Setter/getter for the movement's velocity as a vector. 
   * @param {vec2} velocity   (optional)
   * @return {vec2}
   */
  vector: function(v) {
    if(v !== undefined) {
      this._speed = vec2.length(v);
      this._angle = 0-TentaGL.Math.vectorAngle2D([1,0], v);
      this._calcVector();
    }
    return this._vector.slice(0);
  },
  
  
  /** 
   * @inheritDoc {Toupony.Movement}
   */
  move: function(sprite, context) {
    var vector = this.vector();
    sprite.xy(vec2.add([], sprite.xy(), vector));
    
    sprite.setAxisRotation([0,0,-1], this.angle());
    
    var maxDist = 100;
    if( sprite.x() < -maxDist || sprite.x() > Toupony.STAGE_WIDTH + maxDist || 
        sprite.y() < -maxDist || sprite.y() > Toupony.STAGE_HEIGHT + maxDist) {
      sprite.destroy();
    }
    
    return vector;
  }
};

Util.Inheritance.inherit(Toupony.LinearMovement, Toupony.Movement);

/** 
 * A movement which moves the sprite at a constant speed, but with changing (but
 * decelerating) direction.
 * @param {number} angle              The starting angle, in radians.
 * @param {number} speed              The constant speed, in pixels per frame.
 * @param {number} angleSpeed         The rate at which the angle changes, in radians per frame.
 * @param {number} angleDeceleration  The rate of the angle's deceleration, in radians per square frame.
 */
Toupony.CurvingMovement = function(angle, speed, angleSpeed, angleDeceleration) {
  Toupony.LinearMovement.call(this, angle, speed);
  this._angleSpeed = angleSpeed;
  this._angleDecel = angleDeceleration;
};

Toupony.CurvingMovement.prototype = {
  constructor: Toupony.CurvingMovement,
  
  isaCurvingMovement: true, 
  
  /** 
   * Setter/getter for the angular velocity.
   * Setting this to a negative value will make it rotate clockwise.
   * Setting this to a positive value will make it rotate counter-clockwise.
   */
  angleSpeed: function(speed) {
    if(speed !== undefined) {
      this._angleSpeed = speed;
    }
    return this._angleSpeed;
  },
  
  
  angleDeceleration: function(decel) {
    if(decel !== undefined) {
      this._angleDecel = decel;
    }
    return this._angleSpeed;
  },
  
  /** 
   * @inheritDoc Toupony.Movement
   */
  move: function(sprite, context) {
    var vector = this.vector();
    sprite.xy(vec2.add([], sprite.xy(), vector));
    sprite.setAxisRotation([0,0,-1], this.angle());
    
    var maxDist = 300;
    if( sprite.x() < -maxDist || sprite.x() > Toupony.STAGE_WIDTH + maxDist || 
        sprite.y() < -maxDist || sprite.y() > Toupony.STAGE_HEIGHT + maxDist) {
      sprite.destroy();
    }
    
    // Update the angular velocity.
    this.angle(this.angle() + this._angleSpeed);
    if(this._angleDecel >= Math.abs(this._angleSpeed)) {
      this._angleDecel = 0;
      this._angleSpeed = 0;
    }
    else if(this._angleSpeed > 0) {
      this._angleSpeed -= this._angleDecel;
    }
    else {
      this._angleSpeed += this._angleDecel;
    }
    
    return vector;
  }
  
};

Util.Inheritance.inherit(Toupony.CurvingMovement, Toupony.LinearMovement);

/** 
 * The movement pattern for Rarity's bullets.
 */
Toupony.CycloneDiamondMovement = function() {
  var angleDecel = this.ANGLE_SPEED/2/60;
  Toupony.CurvingMovement.call( this, Math.random()*TentaGL.TAU, 
                                this.SPEED, this.ANGLE_SPEED, angleDecel);
  this._age = 0;
};


Toupony.CycloneDiamondMovement.prototype = {
  constructor: Toupony.CycloneDiamondMovement,
  
  isaCycloneDiamondMovement: true, 
  
  SPEED: 5,
  
  ANGLE_SPEED: TentaGL.TAU*2/60,
  
  
  move: function(sprite, context) {
    this._age++;
    
    if(this._age >= 60) {
      this.angleSpeed(0);
      this.angleDeceleration(0);
      
      var angleDir = 0-TentaGL.Math.vectorAngle2D(this.vector(), [0, -1]);
      
      if(angleDir < 0) {
        this.angle(this.angle() - this.ANGLE_SPEED);
      }
      else {
        this.angle(this.angle() + this.ANGLE_SPEED);
      }
      
      this.speed(this.speed() + 5/60);
    }
    
    return Toupony.CurvingMovement.prototype.move.call(this, sprite, context);
  }
};

Util.Inheritance.inherit(Toupony.CycloneDiamondMovement, Toupony.CurvingMovement);

/** 
 * The homing movement for Twilight's magic missile bullets.
 */
Toupony.MagicMissileMovement = function() {
  Toupony.LinearMovement.call(this, TentaGL.TAU/4, this.SPEED);
};


Toupony.MagicMissileMovement.prototype = {
  constructor: Toupony.MagicMissileMovement,
  
  isaMagicMissileMovement: true,
  
  SPEED: 6,
  
  ANGLE_SPEED: TentaGL.TAU/2/60,
  
  
  /** 
   * @inheritDoc Toupony.LinearMovement
   */
  move: function(bullet, context) {
    // Figure out which enemy is closest.
    var enemies = context.getEnemies();
    var bestDistSq = 200*200;
    var bestEnemy;
    enemies.forEach(function(enemy) {
      var distSq = vec2.sqrDist(bullet.xy(), enemy.xy());
      
      if(distSq < bestDistSq) {
        bestEnemy = enemy;
        bestDistSq = distSq;
      }
    });
    
    // If the bullet is nearby an enemy, change its direction toward that enemy.
    if(bestEnemy !== undefined) {
      var vectorToEnemy = vec2.sub([], bestEnemy.xy(), bullet.xy());
      var angleDir = 0-TentaGL.Math.vectorAngle2D(this.vector(), vectorToEnemy);
      
      if(angleDir < 0) {
        this.angle(this.angle() - this.ANGLE_SPEED);
      }
      else {
        this.angle(this.angle() + this.ANGLE_SPEED);
      }
    }
    
    return Toupony.LinearMovement.prototype.move.call(this, bullet, context);
  }
  
};

Util.Inheritance.inherit(Toupony.MagicMissileMovement, Toupony.LinearMovement);
/** 
 * A pre-fabricated shader program that applies a model-view-projection 
 * transform to vertices in the scene and colors texels using a texture.
 * Lighting/Shading is not provided in this program.
 * @param {WebGLRenderingContext} gl
 */
Toupony.AddColorShader = function(gl) {
  var shaderRoot = TentaGL.ShaderLib.getDefaultShaderPath(gl);
  
  var vertURL = shaderRoot + "simple.vert";
  var fragURL = shaderRoot + "addColor.frag";
  
  var self = this;
  TentaGL.ShaderLoader.load(vertURL, fragURL, function(vertSrc, fragSrc) {
    console.log("\nCreating AddColor shader");
    TentaGL.ShaderProgram.call(self, gl, vertSrc, fragSrc);
    
    self.setAttrGetter("vertexPos", TentaGL.Vertex.prototype.xyz);
    self.setAttrGetter("vertexNormal", TentaGL.Vertex.prototype.normal);
    self.setAttrGetter("vertexTexCoords", TentaGL.Vertex.prototype.texST);
    
    self._opacityUni = self.getUniform("opacity");
    
    self._fogEqUni = self.getUniform("fogEquation");
    self._fogColorUni = self.getUniform("fogColor");
    self._fogDensityUni = self.getUniform("fogDensity");
    
    self._mvpUni = self.getUniform("mvpTrans");
    self._normalUni = self.getUniform("normalTrans");
    
    self._colorUni = self.getUniform("addedColor");
    self._texUni = self.getUniform("tex");
  });
};

Toupony.AddColorShader.prototype = {
  
  constructor: Toupony.AddColorShader,
  
  isaAddColorShader: true,
  
  /** 
   * Sets the uniform variables for using a solid color instead of using a 
   * texture for color. Solid colors are compatible with bump maps! Just call 
   * setBump after setColor, since setColor unsets the useBumpTex uniform.
   * @param {WebGLRenderingContext} gl
   * @param {vec4} rgba
   */
  setColor: function(gl, rgba) {
    this._colorUni.set(gl, rgba);
  },
  
  /** 
   * Sets the value of the uniform variable for the primary texture offset. 
   * @param {WebGLRenderingContext} gl
   * @param {int} value
   */
  setTex: function(gl, value) {
    this._texUni.set(gl, [value]);
  }
};


/** 
 * Loads SimpleShader into the ShaderLib, with the specified name. 
 * @param {WebGLRenderingContext} gl
 * @param {name}  The name used to reference the shader program from the ShaderLib.
 * @return {TentaGL.ShaderProgram}
 */
Toupony.AddColorShader.load = function(gl, name) {
  var program = new Toupony.AddColorShader(gl);
  TentaGL.ShaderLib.add(gl, name, program);
  
  return program;
};


Util.Inheritance.inherit(Toupony.AddColorShader, TentaGL.SimpleShader);

/** 
 * An interface for sprites that are animated.
 */
Toupony.Animatable = function() {};

Toupony.Animatable.prototype = {
  constructor: Toupony.Animatable,
  
  isaAnimatable: true,
  
  /** 
   * Runs one iteration of the sprite's animation.
   */
  animate: function() {}
};
/** 
 * A mix-in for destroyable sprites.
 */
Toupony.Destroyable = function() {};


Toupony.Destroyable.prototype = {
  
  constructor: Toupony.Destroyable,
  
  isaDestroyable: true,
  
  _isDestroyed: false,
  
  
  /** 
   * Returns whether this sprite has been destroyed.
   * @return {boolean}
   */
  isDestroyed: function() {
    return this._isDestroyed;
  },
  
  
  /** 
   * Marks this sprite as destroyed.
   */
  destroy: function() {
    this._isDestroyed = true;
    this._notifyDestroyHandlers();
    this._destroyHandlers = [];
  },
  
  
  /** 
   * Runs all the destroy handlers for this.
   */
  _notifyDestroyHandlers: function() {
    if(this._destroyHandlers !== undefined) {
      for(var i=0; i < this._destroyHandlers.length; i++) {
        var handler = this._destroyHandlers[i];
        handler(this);
      }
    }
  },
  
  
  /** 
   * Subscribes a destroy handler function which will be called for this when 
   * this is destroyed.
   * @param {function(this: Destroyable)} handler    
   */
  addDestroyHandler: function(handler) {
    if(this._destroyHandlers === undefined) {
      this._destroyHandlers = [];
    }
    
    this._destroyHandlers.push(handler);
  },
  
  /** 
   * Unsubscribes a destroy handler function from this. 
   * @param {function(this: Destroyable)} handler  
   */
  removeDestroyHandler: function(handler) {
    if(this._destroyHandlers !== undefined) {
      var index = this._destroyHandlers.indexOf(handler);
      if(index >= 0) {
        this._destroyHandlers.splice(index, 1);
      }
    }
  },
  
  
  /** 
   * Unsubscribes all destroy handler functions from this. 
   */
  removeAllDestroyHandlers: function() {
    this._destroyHandlers = [];
  }
};
/** 
 * A mix-in for enemy sprites.
 */
Toupony.Enemy = function() {};

Toupony.Enemy.prototype = {
  constructor: Toupony.Enemy,
  
  isaEnemy: true
};
/**
 * A grouping of similar sprite objects which may be Destroyable or Animatable.
 * A SpriteGroup may even be composed of a hierarchy of other SprittGroups.
 * Destroyed sprites are automatically removed from the group.
 * @constructor
 * @param {array: TentaGL.Renderable} sprites   Optional. An initial list of sprites
 *                                              for the group. 
 */
Toupony.SpriteGroup = function(sprites) {
  if(sprites === undefined) {
    sprites = [];
  }
  this._sprites = sprites;
};

Toupony.SpriteGroup.prototype = {
  
  constructor: Toupony.SpriteGroup,
  
  isaSpriteGroup: true, 
  
  /**
   * Returns a list of the sprites in this group. Destroyable sprites that
   * have been destroyed are automatically removed from the group when they are 
   * encountered.
   * @return {array: Sprite}
   */
  getAll: function() {
    return this._sprites.slice(0);
  },
  
  
  /**
   * Returns a filtered list of the sprites in this group. 
   * @param {function(sprite: TentaGL.Sprite): boolean} filterFunc. 
   *            The result list will only contain the sprites for which this
   *            function returns true.
   * @return {array: Sprite}
   */ 
  filter: function(filterFunc) {
    var result = [];
    
    this.forEach(function(sprite) {
      if(filterFunc(sprite)) {
        result.push(sprite);
      }
    });
    
    return result;
  },
  
  
  /** 
   * Executes a function over each sprite in this group.
   * @param {function(sprite: TentaGL.Sprite)} func
   */
  forEach: function(func) {
    for(var i=0; i < this._sprites.length; i++) {
      var sprite = this._sprites[i];
      func(sprite);
    }
  },
  
  
  /** 
   * Adds a sprite to the end of this group. 
   * @param {TentaGL.Sprite} sprite
   */
  add: function(sprite) {
    this._sprites.push(sprite);
    
    // Automatically remove the sprite from this group if it is destroyed. 
    if(sprite.isaDestroyable) {
      var self = this;
      sprite.addDestroyHandler(function(destroyedSprite) {
        self.remove(destroyedSprite);
      });
    }
  },
  
  /** 
   * Adds a list of sprites to the sprite group.
   * @param {array: TentaGL.Sprite} sprites
   */
  addAll: function(sprites) {
    for(var i=0; i < sprites.length; i++) {
      var sprite = sprites[i];
      this.add(sprite);
    }
  },
  
  
  /** 
   * Removes a sprite from this group.
   * @param {TentaGL.Sprite} sprite
   */
  remove: function(sprite) {
    var index = this._sprites.indexOf(sprite);
    if(index >= 0) {
      this._sprites.splice(index, 1);
    }
  },
  
  /** 
   * Removes all sprites from this group. 
   */
  removeAll: function() {
    this._sprites = [];
  },
  
  
  /**
   * Returns the number of sprites in this group.
   * @return {uint}
   */
  size: function() {
    return this._sprites.length;
  },
  
  /** 
   * Sorts the sprites in the group according to the ordering defined
   * by some comparison function.
   * @param {function(a: TentaGL.Sprite, b: TentaGL.Sprite)} func   The comparison function.
   */
  sort: function(func) {
    this._sprites.sort(func);
  },
  
  
  /**
   * Animates all Animatable sprites in the group.
   */ 
  animate: function() {
    this.forEach(function(sprite) {
      if(sprite.isaAnimatable) {
        sprite.animate();
      }
    });
  },
  
  
  /**
   * Renders all sprites in the group.
   * @param {WebGLRenderingContext} gl
   */
  render: function(gl) {
    this.forEach(function(sprite) {
      sprite.render(gl);
    });
  }
};

Util.Inheritance.inherit(Toupony.SpriteGroup, TentaGL.Renderable);
Util.Inheritance.inherit(Toupony.SpriteGroup, Toupony.Animatable);
Util.Inheritance.inherit(Toupony.SpriteGroup, Toupony.Destroyable);


/**
 * Base class for player and enemy bullet sprites.
 * @abstract
 * @constructor
 * @param {vec2} xy
 * @param {number} radius
 */
Toupony.Bullet = function(xy, radius) {
  TentaGL.Sprite.call(this, xy);
  this._radius = radius;
  
  this._movement = new Toupony.LinearMovement(0,0);
  this._velocity = [0,0];
  this._angle = 0;
};

Toupony.Bullet.prototype = {
  
  constructor: Toupony.Bullet,
  
  isaBullet: true,
  
  
  /** 
   * Setter/getter for the bullet's movement physics.
   * @param {Toupony.Movement} newMovement    optional. If given, this becomes the bullet's new movement.
   * @return {Toupony.Movement}
   */
  movement: function(newMovement) {
    if(newMovement) {
      this._movement = newMovement;
    }
    return this._movement;
  },
  
  
  /** 
   * Runs the movement physics for this bullet.
   * @param {Toupony.MainLevel} context
   */
  move: function(context) {
    this._velocity = this._movement.move(this, context);
  },
  
  
  /** 
   * Returns the current velocity vector of the bullet.
   * @return {vec2}
   */
  getVelocity: function() {
    return this._velocity;
  },
  
  
  /** 
   * Returns the angle of the direction the bullet is currently moving in,
   * in radians in the range [-PI, PI].
   * @return {number} 
   */
  getAngle: function() {
    var dx = this._velocity[0];
    var dy = this._velocity[1];
    return 0-Math.atan(dy, dx);
  },
  
  
  /** 
   * Setter/getter for the radius of the bullet.
   * @param {number} radius
   * @return {number}
   */
  radius: function(radius) {
    if(radius !== undefined) {
      this._radius = radius;
    }
    return this._radius;
  },
  
  
  /** 
   * Returns the name of the material (most likely a Texture) used to render 
   * this bullet.
   * @abstract
   * @return {string}
   */
  getMaterialName: function() {}
};


Util.Inheritance.inherit(Toupony.Bullet, TentaGL.Sprite);
Util.Inheritance.inherit(Toupony.Bullet, Toupony.Animatable);
Util.Inheritance.inherit(Toupony.Bullet, Toupony.Destroyable);

/** 
 * Base class for Bullets produced by an enemy.
 * This implementation is good for bullets that are circular-shaped 
 * in nature. Elliptical shapes are also supported through scaling on the 
 * X or Y axis of the sprite.
 * @abstract
 * @constructor
 * @param {vec2} xy
 * @param {Toupony.Movement} movement   Optional. By default a LinearMovement 
 *                                      with vector [0,1] is provided.
 * @param {number} radius               Optional. Default 8.
 * @param {TentaGL.Color} color         Optional. The color for the bullet. 
 *                                      Default black.
 */
Toupony.EnemyBullet = function(xy, radius, color) {
  if(!radius) {
    radius = 8;
  }
  if(color === undefined) {
    color = TentaGL.Color.BLACK;
  }
  
  Toupony.Bullet.call(this, xy, radius);
  this.color(color);
};

/** 
 * Loads the graphics resources for enemy bullets.
 * @param {WebGLRenderingContext} gl
 */
Toupony.EnemyBullet.load = function(gl) {
  TentaGL.MaterialLib.add(gl, "bulletA", new TentaGL.Texture.fromURL(gl, "img/bullet/bulletA.png"));
  TentaGL.MaterialLib.add(gl, "bulletB", new TentaGL.Texture.fromURL(gl, "img/bullet/bulletB.png"));
  TentaGL.MaterialLib.add(gl, "bulletC", new TentaGL.Texture.fromURL(gl, "img/bullet/bulletC.png"));
  TentaGL.MaterialLib.add(gl, "bulletD", new TentaGL.Texture.fromURL(gl, "img/bullet/bulletD.png"));
  TentaGL.MaterialLib.add(gl, "bulletE", new TentaGL.Texture.fromURL(gl, "img/bullet/bulletE.png"));
  TentaGL.MaterialLib.add(gl, "bulletF", new TentaGL.Texture.fromURL(gl, "img/bullet/bulletF.png"));
  TentaGL.MaterialLib.add(gl, "bulletG", new TentaGL.Texture.fromURL(gl, "img/bullet/bulletG.png"));
};


/** 
 * Unloads the graphics resources for enemy bullets.
 * @param {WebGLRenderingContext} gl
 */
Toupony.EnemyBullet.clean = function(gl) {
  TentaGL.MaterialLib.remove(gl, "bulletA");
  TentaGL.MaterialLib.remove(gl, "bulletB");
  TentaGL.MaterialLib.remove(gl, "bulletC");
  TentaGL.MaterialLib.remove(gl, "bulletD");
  TentaGL.MaterialLib.remove(gl, "bulletE");
  TentaGL.MaterialLib.remove(gl, "bulletF");
  TentaGL.MaterialLib.remove(gl, "bulletG");
};


Toupony.EnemyBullet.prototype = {
  constructor: Toupony.EnemyBullet,
  
  isaEnemyBullet: true,
  
  
  /** 
   * Setter/getter for the bullet's color. 
   * @param {uint32} newColor
   * 
   */
  color: function(newColor) {
    if(newColor) {
      this._color = newColor;
    }
    return this._color;
  },
  
  
  /** 
   * Draws the bullet using the addColor shader. This allows us to make the
   * bullets any color we want using just one black-and-white texture of the 
   * bullet.
   */
  draw: function(gl) {
    var diameter = this._radius*2;
    
    TentaGL.ViewTrans.scale(gl, [diameter, diameter]);
    TentaGL.ViewTrans.translate(gl, [0.5, 0.5]);
    
    TentaGL.ShaderLib.use(gl, "addColor");
    var shader = TentaGL.ShaderLib.current(gl);
    shader.setColor(gl, this._color);
    
    var material = this.getMaterialName();
    TentaGL.MaterialLib.use(gl, material);
    TentaGL.ModelLib.render(gl, "unitSprite");
  }
  
};

Util.Inheritance.inherit(Toupony.EnemyBullet, Toupony.Bullet);
Util.Inheritance.inherit(Toupony.EnemyBullet, Toupony.Enemy);
/**
 * Base class for player bullet sprites.
 * @abstract
 * @constructor
 */
Toupony.PlayerBullet = function(xy, radius, damage) {
  Toupony.Bullet.call(this, xy, radius);
  this._damage = damage;
  this.opacity(0.7);
};


Toupony.PlayerBullet.prototype = {
  constructor: Toupony.PlayerBullet,
  
  isaPlayerBullet: true,
  
  /** 
   * Returns the amount of damage this bullet does to enemies and obstacles.
   * @return {number}
   */
  getDamage: function() {
    return this._damage;
  },
  
  
  /** 
   * @inheritDoc Toupony.Bullet
   */
  move: function(context) {
    var trailEffect = this.createTrailEffect(); //Toupony.MagicMissileBullet.createTrail(this.xy(), this.radius(), angle);
    context.getSpecialFX().add(trailEffect);
    
    // Move the bullet.
    Toupony.Bullet.prototype.move.call(this, context);
    trailEffect.setAxisRotation([0,0,-1], this.getAngle());
  },
  
  
  /** 
   * Produces a trail special effect for the bullet. 
   * @return {Toupony.SpecialFX} 
   */
  createTrailEffect: function() {
    var dia = this.radius()*2;
    var lifeSpan = this.getTrailLifeSpan();
    var material = this.getTrailMaterialName();
    
    var effect = new Toupony.SpecialFX(this.xy(), lifeSpan);
    effect.fadeEffect = this.getTrailFadeFunction();    
    effect.draw = function(gl) {
      TentaGL.ShaderLib.use(gl, "simple");
      var shader = TentaGL.ShaderLib.current(gl);
      shader.setOpacity(gl, this.opacity());
      
      TentaGL.ViewTrans.scale(gl, [dia, dia]);
      TentaGL.ViewTrans.translate(gl, [-0.5, -0.5]);
      
      TentaGL.MaterialLib.use(gl, material);
      TentaGL.ModelLib.render(gl, "unitSprite");
    };
    
    return effect;
  },
  
  
  /** 
   * @inheritDoc TentaGL.Sprite
   */
  draw: function(gl) {
    var diameter = this.radius()*2;
    
    TentaGL.ViewTrans.scale(gl, [diameter, diameter]);
    TentaGL.ViewTrans.translate(gl, [-0.5, -0.5]);
    
    TentaGL.ShaderLib.use(gl, "simple");
    TentaGL.MaterialLib.use(gl, this.getMaterialName());
    TentaGL.ModelLib.render(gl, "unitSprite");
  },
  
  
  //////// Abstract methods
  
  /** 
   * Returns the life span of the bullet's trail effect particles, in frames.
   * @abstract
   * @return {uint}
   */
  getTrailLifeSpan: function() {},
  
  /** 
   * Returns the name of the material used for the bullet's 
   * trail effect particles.
   * @abstract
   * @return {string}
   */
  getTrailMaterialName: function() {},
  
  /** 
   * Returns the fade function for the bullet's trail effect.
   * @abstract
   * @return {function(alpha: float)}
   */
  getTrailFadeFunction: function() {}
};

Util.Inheritance.inherit(Toupony.PlayerBullet, Toupony.Bullet);
/** 
 * The bullet for Rarity's Cyclone Diamond weapon. It creates a whirlwind of 
 * diamonds which then curve toward the top of the screen.
 * @constructor
 * @param {vec2} xy
 * @param {boolean} isLarge
 * @param {number} damage
 */
Toupony.CycloneDiamondBullet = function(xy, radius, damage) {
  Toupony.PlayerBullet.call(this, xy, radius, damage);
  
  var cycloneMovement = new Toupony.CycloneDiamondMovement();
  this.movement(cycloneMovement);
};



/** 
 * Creates a small bullet.
 * @param {vec2} xy
 * @return {Toupony.CycloneDiamondBullet}
 */
Toupony.CycloneDiamondBullet.createSmall = function(xy) {
  var radius = 16;
  var damage = 2;
  return new Toupony.CycloneDiamondBullet(xy, radius, damage);
};


/** 
 * Creates a large bullet.
 * @param {vec2} xy
 * @return {Toupony.CycloneDiamondBullet}
 */
Toupony.CycloneDiamondBullet.createLarge = function(xy) {
  var radius = 24;
  var damage = 3;
  return new Toupony.CycloneDiamondBullet(xy, radius, damage);
};



/** 
 * Loads the sprite's WebGL resources. 
 * @param {WebGLRenderingContext} gl
 */
Toupony.CycloneDiamondBullet.load = function(gl) {
  TentaGL.MaterialLib.add(gl, "RarityBullet", TentaGL.Texture.fromURL(gl, "img/bullet/RarityBullet.png"));
  TentaGL.MaterialLib.add(gl, "RarityBulletTrail", TentaGL.Texture.fromURL(gl, "img/bullet/RarityBulletTrail.png"));
};

/** 
 * Unloads the sprite's WebGL resources.
 * @param {WebGLRenderingContext} gl
 */
Toupony.CycloneDiamondBullet.clean = function(gl) {
  TentaGL.MaterialLib.remove(gl, "RarityBullet");
  TentaGL.MaterialLib.remove(gl, "RarityBulletTrail");
};


Toupony.CycloneDiamondBullet.prototype = {
  constructor: Toupony.CycloneDiamondBullet,
  
  isaCycloneDiamondBullet: true,
  
  /** 
   * @inheritDoc Toupony.Bullet
   */
  getMaterialName: function() {
    return "RarityBullet";
  },
  
  /** 
   * @inheritDoc Toupony.PlayerBullet
   */
  getTrailMaterialName: function() {
    return "RarityBulletTrail";
  },
  
  /** 
   * @inheritDoc Toupony.PlayerBullet
   */
  getTrailLifeSpan: function() {
    return 20;
  },
  
  /** 
   * @inheritDoc Toupony.PlayerBullet
   */
  getTrailFadeFunction: function() {
    return function(alpha) {
      var opacity = TentaGL.Math.mix(0.0, 0.7, alpha);
      this.opacity(opacity);
      
      var scale = TentaGL.Math.mix(1.0, 0.2, alpha);
      this.scale([scale, scale]);
    };
  }
};

Util.Inheritance.inherit(Toupony.CycloneDiamondBullet, Toupony.PlayerBullet);
/**
 * The bullet for Twilight's Magic Missile weapon. Magical stars home in on nearby enemies.
 * @constructor
 * @param {vec2} xy
 * @param {boolean} isLarge
 * @param {number} damage
 */
Toupony.MagicMissileBullet = function(xy, radius, damage) {
  var homingMovement = new Toupony.MagicMissileMovement();
  
  Toupony.PlayerBullet.call(this, xy, radius, damage);
  this.movement(homingMovement);
};


/** 
 * Creates a small bullet.
 * @param {vec2} xy
 * @return {Toupony.MagicMissileBullet}
 */
Toupony.MagicMissileBullet.createSmall = function(xy) {
  var radius = 16;
  var damage = 1;
  return new Toupony.MagicMissileBullet(xy, radius, damage);
};


/** 
 * Creates a large bullet.
 * @param {vec2} xy
 * @return {Toupony.MagicMissileBullet}
 */
Toupony.MagicMissileBullet.createLarge = function(xy) {
  var radius = 24;
  var damage = 2;
  return new Toupony.MagicMissileBullet(xy, radius, damage);
};




/** 
 * Loads the sprite's WebGL resources. 
 * @param {WebGLRenderingContext} gl
 */
Toupony.MagicMissileBullet.load = function(gl) {
  TentaGL.MaterialLib.add(gl, "TwilightBullet", TentaGL.Texture.fromURL(gl, "img/bullet/TwilightBullet.png"));
  TentaGL.MaterialLib.add(gl, "TwilightBulletTrail", TentaGL.Texture.fromURL(gl, "img/bullet/TwilightBulletTrail.png"));
};


/** 
 * Unloads the sprite's WebGL resources.
 * @param {WebGLRenderingContext} gl
 */
Toupony.MagicMissileBullet.clean = function(gl) {
  TentaGL.MaterialLib.remove(gl, "TwilightBullet");
  TentaGL.MaterialLib.remove(gl, "TwilightBulletTrail");
};





Toupony.MagicMissileBullet.prototype = {
  constructor: Toupony.MagicMissileBullet,
  
  isaMagicMissileBullet: true,
  
  
  /** 
   * @inheritDoc Toupony.Bullet
   */
  getMaterialName: function() {
    return "TwilightBullet";
  },
  
  /** 
   * @inheritDoc Toupony.PlayerBullet
   */
  getTrailMaterialName: function() {
    return "TwilightBulletTrail";
  },
  
  /** 
   * @inheritDoc Toupony.PlayerBullet
   */
  getTrailLifeSpan: function() {
    return 20;
  },
  
  /** 
   * @inheritDoc Toupony.PlayerBullet
   */
  getTrailFadeFunction: function() {
    return function(alpha) {
      var opacity = TentaGL.Math.mix(0.0, 0.7, alpha);
      this.opacity(opacity);
      
      var scale = TentaGL.Math.mix(1.0, 0.2, alpha);
      this.scale([scale, scale]);
    };
  }
};

Util.Inheritance.inherit(Toupony.MagicMissileBullet, Toupony.PlayerBullet);
/** 
 * Base class for player sprites.
 * @abstract
 * @constructor
 * @param {Toupony.PlayerStats} stats
 */
Toupony.Player = function(stats) {
  TentaGL.Sprite.call(this);
  
  this._stats = stats;
  
  this._focused = false;
  this._hitBoxRotation = 0;
  this._direction = TentaGL.Direction.UP;
  
  this._timer = new TentaGL.FrameTimer();
  this._frameAnimator = Toupony.Player.getFrameAnimator(this._timer);
  this._hitboxAnimator = Toupony.Player.getHitboxAnimator(this._timer);
  this._hitboxOpacity = 0.0;
  
  this._animTex = undefined;
};


/** 
 * Unloads the object's GL memory resources.
 * @param {WebGLRenderingContext} gl
 */
Toupony.Player.clean = function(gl) {
  TentaGL.MaterialLib.remove(gl, "hitBox");
};


/** 
 * Loads the object's GL memory resources.
 * @param {WebGLRenderingContext} gl
 */
Toupony.Player.load = function(gl) {
  TentaGL.MaterialLib.add(gl, "hitBox", TentaGL.Texture.fromURL(gl, "img/char/hitBox.png"));
};


/** 
 * Obtains an animator for the player's animation frame.
 * @param {TentaGL.Timer} timer
 * @return {TentaGL.Animator}
 */
Toupony.Player.getFrameAnimator = function(timer) {
  if(!Toupony.Player._frameAnimation) {
    Toupony.Player._frameAnimation = new TentaGL.DiscreteAnimation(
      [
        new TentaGL.DiscreteKeyframe("1", 0),
        new TentaGL.DiscreteKeyframe("2", 0.25),
        new TentaGL.DiscreteKeyframe("3", 0.5),
        new TentaGL.DiscreteKeyframe("4", 0.75)
      ], 
      500
    );
  }
  var animator = Toupony.Player._frameAnimation.getAnimator(timer);
  animator.start();
  return animator;
};


/** 
 * Obtains an animator for the player's hitbox rotation animation.
 * @param {TentaGL.Timer} timer
 * @return {TentaGL.Animator}
 */
Toupony.Player.getHitboxAnimator = function(timer) {
  if(!Toupony.Player._hitboxAnimation) {
    Toupony.Player._hitboxAnimation = new TentaGL.ScalarAnimation(
      [
        new TentaGL.ScalarKeyframe(0, 0.0),
        new TentaGL.ScalarKeyframe(TentaGL.TAU, 1.0)
      ],
      2000
    );
  }
  var animator =  Toupony.Player._hitboxAnimation.getAnimator(timer);
  animator.start();
  return animator;
};


Toupony.Player.prototype = {
  
  constructor: Toupony.Player, 
  
  isaPlayerSprite: true,
  
  /** 
   * Returns the player's gameplay stats.
   * @return {Toupony.PlayerStats}
   */
  getStats: function() {
    return this._stats;
  },
  
  
  /** 
   * Controls the player with keyboard input.
   * @param {TentaGL.Keyboard} keyboard
   * @param {Toupony.MainLevel} context
   */
  control: function(keyboard, context) {
    this._controlFocus(keyboard, context);
    this._controlMovement(keyboard, context);
    
    this._controlWeapon(keyboard, context);
  // TODO: this._controlBomb(keyboard, context);
    
    this._stayInPlayableArea();
  },
  
  /** 
   * Use the shift key to control whether the player is in focused movement
   * mode or un-focused movement mode.
   * While focused, the player's hit box becomes visible.
   */
  _controlFocus: function(keyboard, context) {
    if(keyboard.isPressed(KeyCode.SHIFT)) {
      this._speed = this.getFocusedSpeed();
      this._focused = true;
      this._fadeHitBoxOpacity(1.0);
    }
    else {
      this._speed = this.getSpeed();
      this._focused = false;
      this._fadeHitBoxOpacity(0.0);
    }
  },
  
  /** 
   * Fades the hit box's opacity gradually to the specified value. 
   * @param {float} targetOpacity
   */
  _fadeHitBoxOpacity: function(targetOpacity) {
    this._hitboxOpacity += (targetOpacity - this._hitboxOpacity)/10;
  },
  
  /** 
   * Uses arrow keys to move the player at their current speed.
   * @param {TentaGL.Keyboard} keyboard
   */
  _controlMovement: function(keyboard, context) {
    if(keyboard.isPressed(KeyCode.LEFT)) {
      this.x(this.x() - this._speed);
      this._direction = TentaGL.Direction.LEFT;
    }
    if(keyboard.isPressed(KeyCode.RIGHT)) {
      this.x(this.x() + this._speed);
      this._direction = TentaGL.Direction.RIGHT;
    }
    
    if(keyboard.isPressed(KeyCode.UP)) {
      this.y(this.y() - this._speed);
      this._direction = TentaGL.Direction.UP;
    }
    if(keyboard.isPressed(KeyCode.DOWN)) {
      this.y(this.y() + this._speed);
      this._direction = TentaGL.Direction.DOWN;
    }
  },
  
  /** 
   * Prevents the player from moving outside the playable area.
   */
  _stayInPlayableArea: function() {
    if(this.x() < 16) {
      this.x(16);
    }
    if(this.x() > Toupony.STAGE_WIDTH - 16) {
      this.x(Toupony.STAGE_WIDTH - 16);
    }
    if(this.y() < 16) {
      this.y(16);
    }
    if(this.y() > Toupony.STAGE_HEIGHT - 16) {
      this.y(Toupony.STAGE_HEIGHT - 16);
    }
  },
  
  
  /** 
   * Cools down the player's weapons and tries to fire the player's weapons
   * if they are holding the shot button.
   * @param {TentaGL.Keyboard} keyboard
   * @param {Toupony.MainLevel} context
   */
  _controlWeapon: function(keyboard, context) {
    var weapon = this.getWeapon();
    
    weapon.update(this, context);
    if(keyboard.isPressed(KeyCode.Z)) {
      weapon.fire(this, context);
    }
  },
  
  /** 
   * Returns whether the player is currently focused.
   * @return {boolean}
   */
  isFocused: function() {
    return this._focused;
  },
  
  
  /**
   * @inheritDoc TentaGL.Sprite
   */
  getWidth: function() {
    return this.getHitboxRadius()*2;
  },
  
  /** 
   * @inheritDoc TentaGL.Sprite
   */
  getHeight: function() {
    return this.getHitboxRadius()*2;
  },
  
  
  /** 
   * @inheritDoc TentaGL.Sprite
   */
  getBounds2D: function() {
    var radius = this.getHitboxRadius();
    var dia = radius*2;
    var x = this.x() - radius;
    var y = this.y() - radius;
    return new TentaGL.Math.Rect2D([x, y], dia, dia);
  },
  
  
  
  /** 
   * Runs one timer tick of animation. 
   * This updates the player's current texture key and the rotation of their hitbox.
   */
  animate: function() {
    this._timer.tick();
    var frame = this.getTexBaseName();
    
    if(this._direction == TentaGL.Direction.LEFT) {
      frame += "Left";
    }
    else if(this._direction == TentaGL.Direction.RIGHT) {
      frame += "Right";
    }
    else {
      frame += "Up";
    }
    
    frame += this._frameAnimator.animate();
    
    this._animTex = frame;
    this._hitBoxRotation = this._hitboxAnimator.animate();
  },
  
  
  
  /** 
   * Renders the player's hitbox. 
   * @param {WebGLRenderingContext} gl
   */
  renderHitbox: function(gl) {
    TentaGL.ViewTrans.push(gl);
    
    var program = TentaGL.ShaderLib.current(gl);
    if(program.setOpacity) {
      program.setOpacity(gl, this._hitboxOpacity);
    }
    
    var dia = this.getHitboxRadius() * 2;
    
    TentaGL.ViewTrans.scale(gl, [dia, dia]);
    TentaGL.ViewTrans.rotate(gl, [0, 0, 1], this._hitBoxRotation);
    TentaGL.ViewTrans.translate(gl, [-0.5, -0.5]);
    
    TentaGL.MaterialLib.use(gl, "hitBox");
    TentaGL.ModelLib.render(gl, "unitSprite");
    
    TentaGL.ViewTrans.pop(gl);
  },
  
  
  render: function(gl) {
    TentaGL.Sprite.prototype.render.call(this, gl);
    this.getWeapon().render(gl);
  //  this.getBounds2D().render(gl, "red");
  },
  
  
  draw: function(gl) {
    var playerFrame = TentaGL.MaterialLib.get(gl, this._animTex);
    playerFrame.render(gl, true);
    
    TentaGL.ViewTrans.translate(gl, this.anchor());
    this.renderHitbox(gl);
  },
  
  
  //////// Abstract methods
  
  /** 
   * Returns the player's team code.
   * @return {enum: Toupony.PlayerTeams}
   */
  getTeam: function() {},
  
  
  /** 
   * Returns the base name of the textures used for the player's animations.
   * @return {String}
   */
  getTexBaseName: function() {},
  
  
  /** 
   * Returns the player's unfocused speed.
   * @return {number}
   */
  getSpeed: function() {},
  
  
  /** 
   * Returns the player's focused speed.
   * @return {number}
   */
  getFocusedSpeed: function() {},
  
  
  /** 
   * Returns the radius of the player's hitbox.
   * @return {number}
   */
  getHitboxRadius: function() {},
  
  
  /** 
   * Returns the player's current weapon.
   * @return {Toupony.Weapon}
   */
  getWeapon: function() {}
  
  
  
};


Util.Inheritance.inherit(Toupony.Player, TentaGL.Sprite);
Util.Inheritance.inherit(Toupony.Player, Toupony.Animatable);

/** 
 * Used for creating Player instances.
 */
Toupony.PlayerFactory = {
  
  /** 
   * Creates a player sprite instance based on the specified gameplay settings.
   * @param {Toupony.GameConfig} config
   * @param {Toupony.GameplayMode} mode
   * @return {Toupony.Player}
   */
  createPlayer: function(config, mode) {
    var team = mode.getTeam();
    var stats = new Toupony.PlayerStats(config, mode);
    
    if(team == Toupony.PlayerTeams.TWI_RARE) {
      return new Toupony.TwiPlayer(stats);
    }
    else if (team == Toupony.PlayerTeams.DASH_PIE) {
      return new Toupony.DashPlayer(stats);
    }
    else if(team == Toupony.PlayerTeams.FLUTTER_JACK) {
      return new Toupony.FlutterPlayer(stats);
    }
    else if(team == Toupony.PlayerTeams.DERPY) {
      return new Toupony.DerpyPlayer(stats);
    }
  }
  
};

/** 
 * Twilight/Rarity team.
 * @constructor
 * @param {Toupony.PlayerStats} stats
 */
Toupony.TwiPlayer = function(stats) {
  Toupony.Player.call(this, stats);
  
  this.anchor([18, 22, 0]);
  this._twilightWeapon = new Toupony.MagicMissileWeapon();
  this._rarityWeapon = new Toupony.CycloneDiamondWeapon();
};


Toupony.TwiPlayer.load = function(gl) {
  TentaGL.PixelData.fromURL("img/char/Twilight.png", function(pixels) {
    console.log("Loading Twilight frames.");
    
    var transColor = TentaGL.Color.Hex(0xFFFF00FF);
    pixels = pixels.filter(new TentaGL.RGBAFilter.TransparentColor(transColor));
    
    var frames = pixels.toSpriteSheet(38, 48, 1);
    TentaGL.MaterialLib.add(gl, "TwiUp1", TentaGL.Texture.fromPixelData(gl, frames[0]));
    TentaGL.MaterialLib.add(gl, "TwiUp2", TentaGL.Texture.fromPixelData(gl, frames[1]));
    TentaGL.MaterialLib.add(gl, "TwiUp3", TentaGL.Texture.fromPixelData(gl, frames[2]));
    TentaGL.MaterialLib.add(gl, "TwiUp4", TentaGL.Texture.fromPixelData(gl, frames[3]));
    
    TentaGL.MaterialLib.add(gl, "TwiLeft1", TentaGL.Texture.fromPixelData(gl, frames[4]));
    TentaGL.MaterialLib.add(gl, "TwiLeft2", TentaGL.Texture.fromPixelData(gl, frames[5]));
    TentaGL.MaterialLib.add(gl, "TwiLeft3", TentaGL.Texture.fromPixelData(gl, frames[6]));
    TentaGL.MaterialLib.add(gl, "TwiLeft4", TentaGL.Texture.fromPixelData(gl, frames[7]));
    
    TentaGL.MaterialLib.add(gl, "TwiRight1", TentaGL.Texture.fromPixelData(gl, frames[8]));
    TentaGL.MaterialLib.add(gl, "TwiRight2", TentaGL.Texture.fromPixelData(gl, frames[9]));
    TentaGL.MaterialLib.add(gl, "TwiRight3", TentaGL.Texture.fromPixelData(gl, frames[10]));
    TentaGL.MaterialLib.add(gl, "TwiRight4", TentaGL.Texture.fromPixelData(gl, frames[11]));
    
    Toupony.TwiPlayer._texLoaded = true;
  });
  
  Toupony.MagicMissileWeapon.load(gl);
  Toupony.CycloneDiamondWeapon.load(gl);
};


Toupony.TwiPlayer.clean = function(gl) {
  TentaGL.MaterialLib.remove(gl, "TwiUp1");
  TentaGL.MaterialLib.remove(gl, "TwiUp2");
  TentaGL.MaterialLib.remove(gl, "TwiUp3");
  TentaGL.MaterialLib.remove(gl, "TwiUp4");
  
  TentaGL.MaterialLib.remove(gl, "TwiLeft1");
  TentaGL.MaterialLib.remove(gl, "TwiLeft2");
  TentaGL.MaterialLib.remove(gl, "TwiLeft3");
  TentaGL.MaterialLib.remove(gl, "TwiLeft4");
  
  TentaGL.MaterialLib.remove(gl, "TwiRight1");
  TentaGL.MaterialLib.remove(gl, "TwiRight2");
  TentaGL.MaterialLib.remove(gl, "TwiRight3");
  TentaGL.MaterialLib.remove(gl, "TwiRight4");
  
  Toupony.TwiPlayer._texLoaded = false;
  
  Toupony.MagicMissileWeapon.clean(gl);
  Toupony.CycloneDiamondWeapon.clean(gl);
};



Toupony.TwiPlayer.prototype = {
  
  constructor: Toupony.TwiRarePlayer,
  
  isaTwiRarePlayer: true,
  
  
  
  render: function(gl) {
    if(!Toupony.TwiPlayer._texLoaded) {
      return;
    }
    else {
      Toupony.Player.prototype.render.call(this, gl);
    }
  },
  
  
  /**
   * @inheritDoc Toupony.Player
   */
  getTeam: function() {
    return Toupony.PlayerTeams.TWI_RARE;
  },
  
  /**
   * @inheritDoc Toupony.Player
   */
  getTexBaseName: function() {
    if(this._focused) {
      return "Twi";
    }
    else {
      return "Twi";
    }
  },
  
  /**
   * @inheritDoc Toupony.Player
   */
  getSpeed: function() {
    return 4;
  },
  
  /**
   * @inheritDoc Toupony.Player
   */
  getFocusedSpeed: function() {
    return 1.5;
  },
  
  /**
   * @inheritDoc Toupony.Player
   */
  getHitboxRadius: function() {
    return 4;
  },
  
  /** 
   * @inheritDoc Toupony.Player
   */
  getWeapon: function() {
    if(this.isFocused()) {
      return this._rarityWeapon;
    }
    else {
      return this._twilightWeapon;
    }
  },
  
};

Util.Inheritance.inherit(Toupony.TwiPlayer, Toupony.Player);

/**
 * Base class for flashy, temporary sprites used for special particle effects.
 * @abstract
 * @constructor
 * @param {vec2} xy
 * @param {uint} lifeSpan   The number of frames before the effect is destroyed.
 * @param {Toupony.Movement} movement    Optional. Default, stationary movement.
 */
Toupony.SpecialFX = function(xy, lifeSpan, movement) {
  TentaGL.Sprite.call(this, xy);
  this._lifeSpan = lifeSpan;
  this._age = 0;
  
  if(movement === undefined) {
    movement = new Toupony.Movement(); // Doesn't move.
  }
  this._movement = movement;
};

Toupony.SpecialFX.prototype = {
  constructor: Toupony.SpecialFX,
  
  isaSpecialFX: true,
  
  /** 
   * Returns the life span of the effect.
   * @return {uint}
   */
  getLifeSpan: function() {
    return this._lifeSpan;
  },
  
  /** 
   * Returns the current age of the effect.
   * @return {uint}
   */
  getAge: function() {
    return this._age;
  },
  
  /** 
   * @inheritDoc Toupony.Animatable
   */
  animate: function() {
    this._age++;
    if(this._age == this._lifeSpan) {
      this.destroy();
    }
    
    this._movement.move(this);
    
    var alpha = this._age/this._lifeSpan;
    this.fadeEffect(alpha);
  },
  
  
  /** 
   * Sets the properties of the effect based on the a 
   * parametric value of its age.
   * @param {float} alpha   The parameterized value of the effect's age, 
   *                        in the range [0, 1].
   */
  fadeEffect: function(alpha) {}
  
};

Util.Inheritance.inherit(Toupony.SpecialFX, TentaGL.Sprite);
Util.Inheritance.inherit(Toupony.SpecialFX, Toupony.Animatable);
Util.Inheritance.inherit(Toupony.SpecialFX, Toupony.Destroyable);
/**
 * Base class for the game's stages.
 * @abstract
 * @constructor
 */
Toupony.Stage = function() {
  this._time = 0;
}

Toupony.Stage.prototype = {
  constructor: Toupony.Stage, 
  
  isaStage: true,
  
  /** 
   * Runs one iteration through the stage's events and then increments the
   * stage's internal timer. 
   * @param {Toupony.MainLevel} mainLevel
   */
  run: function(mainLevel) {
    this._timeWasSet = false;
    this.runCurrentFrame(mainLevel);
    
    // Increment the time value if the time wasn't set during the the current frame.
    if(this._timeWasSet) {
      this._timeWasSet = false;
    }
    else {
      this._time++;
    }
  },
  
  
  /** 
   * Runs the stage's events for the current time value. Override this!
   * @abstract
   * @param {Toupony.MainLevel} mainLevel
   * @param {uint} time
   */
  runCurrentFrame: function(mainLevel) {},
  
  
  /** 
   * Setter/getter for the stage's current time.
   * @param {uint} time   Optional.
   * @return {uint}
   */
  time: function(time) {
    if(time !== undefined) {
      this._time = time;
      this._timeWasSet = true;
    }
    return this._time;
  }
};

/** 
 * An object encapsulating the player's stats such as their lives, bombs, score,
 * etc.
 * @constructor
 * @param {Toupony.MainLevel} mainLevel
 */
Toupony.PlayerStats = function(config, mode) {
  var difficulty = mode.getDifficulty();
  var team = mode.getTeam();
  
  this._lives = mode.getStartLives();
  if(this._lives == -1) {
    this._lives = config.startLives();
  }
  
  this._bombs = mode.getStartBombs();
  if(this._bombs == -1) {
    this._bombs = config.startBombs();
  }
  
  this._score = 0;
  this._power = 0.0;
  this._graze = 0;
  this._continues = 3;
};


Toupony.PlayerStats.prototype = {
  
  constructor: Toupony.PlayerStats,
  
  isaPlayerStats: true,
  
  
  /** 
   * Setter/getter for the player's number of lives.
   * @param {int} n
   * @return {int}
   */
  lives: function(n) {
    if(n !== undefined) {
      this._lives = n;
    }
    return this._lives;
  },
  
  /** 
   * Setter/getter for the player's number of bombs.
   * @param {int} n
   * @return {int}
   */
  bombs: function(n) {
    if(n !== undefined) {
      this._bombs = n;
    }
    return this._bombs;
  },
  
  /** 
   * Setter/getter for the player's power.
   * @param {float} n
   * @return {float}
   */
  power: function(n) {
    if(n !== undefined) {
      n = Math.max(0, Math.min(n, 4.0));
      this._power = n;
    }
    return this._power;
  },
  
  /**
   * Setter/getter for the player's graze.
   * @param {int} n
   * @return {int}
   */
  graze: function(n) {
    if(n !== undefined) {
      this._graze = n;
    }
    return this._graze;
  },
  
  
  /** 
   * Setter/getter for the player's score. 
   * @param {uint} n
   * @return {uint}
   */
  score: function(n) {
    if(n !== undefined) {
      this._score = n;
    }
    return this._score;
  }
};
/** 
 * Data about a high score.
 * @param {uint} score    The high score.
 * @param {string} name   The name entered by the player who achieved the high score.
 * @param {enum: Toupony.StageProgress} progress    The ending stage for the high score.
 */
Toupony.HighScore = function(score, name, progress) {
  this._score = score;
  this._name = name;
  this._progress = progress;
  this._dateTime = Util.DateTime.getFormattedDateTime(new Date());
};


/** 
 * Creates a HighScore from its JSON representation. 
 * @param {object}
 * @return {Toupony.HighScore}
 */
Toupony.HighScore.fromJSON = function(jObj) {
  var score = jObj.score;
  var name = jObj.name;
  var dateTime = jObj.dateTime;
  var progress = jObj.progress;
  
  var result = new Toupony.HighScore(score, name, progress);
  result._dateTime = dateTime;
};



Toupony.HighScore.prototype = {
  
  constructor: Toupony.HighScore,
  
  
  /** 
   * Returns the value of the high score.
   * @return {uint}
   */
  getScore: function() {
    return this._score;
  },
  
  /** 
   * Returns the high score's player name.
   * @return {string}
   */
  getName: function() {
    return this._name;
  },
  
  /** 
   * Returns the high score's progress.
   * @return {enum: Toupony.StageProgress}
   */
  getProgress: function() {
    return this._progress;
  },
  
  /** 
   * Returns the date and time string for the high score. 
   * @return {string}
   */
  getDateTime: function() {
    return this._dateTime;
  },
  
  
  /** 
   * Creates a JSON-ified version of the high score.
   * @return {object}
   */
  toJSON: function() {
    var score = this._score;
    var name = this._name;
    var progress = this._progress;
    var dateTime = this._dateTime;
    
    return {
      score: score,
      name: name,
      progress: progress,
      dateTime: dateTime
    };
  }
  
};

/** 
 * The collection of all the saved high scores tables for the game. 
 * The high score tables are separated by difficulty and by player character teams.
 * @constructor
 */
Toupony.HighScoresRecords = function() {
  this._records = {};
  
  this._initForDifficulty(Toupony.Difficulty.EASY);
  this._initForDifficulty(Toupony.Difficulty.NORMAL);
  this._initForDifficulty(Toupony.Difficulty.HARD);
  this._initForDifficulty(Toupony.Difficulty.LUNATIC);
  this._initForDifficulty(Toupony.Difficulty.EXTRA);
};


/** 
 * Produces a HighScoresRecords from a json object representation. 
 * @param {object} jObj
 * @return {Toupony.HighScoresRecords}
 */
Toupony.HighScoresRecords.fromJSON = function(jObj) {
  var result = new Toupony.HighScoresRecords();
  result._records = Util.JSON.clone(jObj);
    
  for(var difficulty in jObj) {
    for(var team in jObj[difficulty]) {
      var jTable = jObj[difficulty][team];
      var table = Toupony.HighScoresTable.fromJSON(jTable);
      
      result._records[difficulty][team] = table;
    }
  }
  
  return result;
};


Toupony.HighScoresRecords.prototype = {
  
  constructor: Toupony.HighScoresRecords,
  
  isaHighScoresRecords: true, 
  
  
  _initForDifficulty: function(dif) {
    this._records[dif] = {};
    
    this._initForTeam(dif, Toupony.PlayerTeams.TWI_RARE);
    this._initForTeam(dif, Toupony.PlayerTeams.DASH_PIE);
    this._initForTeam(dif, Toupony.PlayerTeams.FLUTTER_JACK);
  },
  
  _initForTeam: function(dif, team) {
    this._records[dif][team] = new Toupony.HighScoresTable();
  },
  
  
  /** 
   * Returns the high scores table for a particular difficulty and player team.
   * @param {enum: Toupony.Difficulty} difficulty
   * @param {enum: Toupony.PlayerTeams} team
   * @return {Toupony.HighScoresTable}
   */
  getTable: function(difficulty, team) {
    return this._records[difficulty][team];
  },
  
  
  /** 
   * Produces a JSON representation of the this object. 
   */
  toJSON: function() {
    return Util.JSON.clone(this._records);
  }
};
/** 
 * A table of high scores.
 * @constructor
 * @param {uint} maxSize    Optional. Set a maximum number of high scores for the table. 
 */
Toupony.HighScoresTable = function(maxSize) {
  if(maxSize === undefined) {
    maxSize = 10;
  }
  
  this._highScores = [];
  this._maxSize = maxSize;
};

/** 
 * Constructs a table of high scores from its JSON representation. 
 * @param {object} jObj
 * @return {Toupony.HighScoresTable}
 */
Toupony.HighScoresTable.fromJSON = function(jObj) {
  var maxSize = jObj.maxSize;
  
  var scores = [];
  for(var i=0; i< jObj.scores.length; i++) {
    var highScore = Toupony.HighScore.fromJSON(jObj.scores[i]);
    scores.push(highScore);
  }
  
  var result = new Toupony.HighScoresTable(maxSize);
  result._highScores = scores;
  return result;
};


Toupony.HighScoresTable.prototype = {
  
  constructor: Toupony.HighScoresTable,
  
  isaHighScoresTable : true,
  
  /** 
   * Returns a list of the high scores. 
   * @return {array: Toupony.HighScore}
   */
  getHighScores: function() {
    return this._highScores.slice(0);
  },
  
  /** 
   * Returns the nth high score in the table.
   * @param {int} n
   * @return {Toupony.HighScore}
   */
  getHighScore: function(n) {
    if(n >= 0 && n < this._highScores.length) {
      return this._highScores[n];
    }
    else {
      throw new Error("High score index out of bounds: " + n);
    }
  },
  
  
  /** 
   * Returns the current count of high scores in the table. 
   * @return {uint}
   */
  getCount: function() {
    return this._highScores.length;
  },
  
  
  /** 
   * Attempts to insert a new high score into the table. 
   * @param {Toupony.HighScore}
   */
  addHighScore: function(highScore) {
    var insertIndex = 0;
    for(var i=0; i < this._highScores.length; i++) {
      var current = this._highScores[i];
      
      if(highScore.getScore() > current.getScore()) {
        break;
      }
      else {
        insertIndex++;
      }
    }
    
    this._highScores.splice(insertIndex, 0, highScore);
    this._highScores = this._highScores.slice(0, this._maxSize);
  },
  
  
  /** 
   * Creates a JSON representation of the highscores table.
   * @return {object}
   */
  toJSON: function() {
    var maxSize = this._maxSize;
    var scores = [];
    
    for(var i=0; i< this._highScores.length; i++) {
      var highScore = this._highScores[i];
      scores.push(highScore.toJSON());
    }
    
    return {
      maxSize: maxSize,
      scores: scores
    };
  }
};

/** 
 * Base class for player weapons.
 * @abstact
 * @constructor
 */
Toupony.Weapon = function() {};

Toupony.Weapon.prototype = {
  
  constructor: Toupony.Weapon,
  
  isaWeapon: true,
  
  
  
  /** 
   * Updates the frame state of the weapon. This might update things such as 
   * cool-down timers or satellite positions.
   * @abstract
   * @param {Toupony.Player} player
   * @param {Toupony.MainLevel} context
   */
  update: function(player, context) {},
  
  
  /** 
   * Fires the weapon. Override this!
   * @abstract
   * @param {Toupony.Player} player
   * @param {Toupony.MainLevel} context
   */
  fire: function(player, context) {},
  
  
  /** 
   * Renders any renderable parts of the weapon, such as its satellites.
   * @abstract
   * @param {WebGLRenderingContext} gl
   */
  render: function(gl) {}
  
};


Util.Inheritance.inherit(Toupony.Weapon, TentaGL.Renderable);

/** 
 * Rarity's Cyclone Diamond weapon fires a whirlwind of diamonds forming a 
 * defensive barrier, which gradually steer towards the top of the screen.
 */
Toupony.CycloneDiamondWeapon = function() {
  this._timer = 0;
  this._satAngle = 0;
};


Toupony.CycloneDiamondWeapon.load = function(gl) {
  Toupony.CycloneDiamondBullet.load(gl);
};

Toupony.CycloneDiamondWeapon.clean = function(gl) {
  Toupony.CycloneDiamondBullet.clean(gl);
};


Toupony.CycloneDiamondWeapon.prototype = {
  constructor: Toupony.CycloneDiamondWeapon,
  
  isaCycloneDiamondWeapon: true,
  
  /** 
   * @inheritDoc Toupony.Weapon
   */
  update: function(player, context) {
    var power = player.getStats().power();
    this._coolDown(power);
  },
  
  
  /** 
   * Advances the cool-down timer on the weapon.
   */
  _coolDown: function(power) {
    if(this._timer > 0) {
      this._timer++;
    }
    
    var cooldown;
    if(power >= 3.0) {
      cooldown = 10;
    }
    else if(power >= 1.0) {
      cooldown = 15;
    }
    else {
      cooldown = 20;
    }
    
    
    if(this._timer >= cooldown) {
      this._timer = 0;
    }
  },
  
  
  
  /** 
   * @inheritDoc Toupony.Weapon
   */
  fire: function(player, context) {
    var xy = player.xy();
    var power = player.getStats().power();
    
    if(this._timer == 0) {
      this._timer = 1;
      
      var bullet = Toupony.CycloneDiamondBullet.createSmall(xy);
      context.getPlayerBullets().add(bullet);
    }
  }
  
};

Util.Inheritance.inherit(Toupony.CycloneDiamondWeapon, Toupony.Weapon);
/** 
 * Twilight Sparkle's Magic Missile weapon fires weak homing shots.
 */
Toupony.MagicMissileWeapon = function() {
  this._timer = 0;
  this._satAngle = 0;
};


Toupony.MagicMissileWeapon.load = function(gl) {
  Toupony.MagicMissileBullet.load(gl);
  // TODO: Load bullet trail graphics.
  // TODO: Load satellite graphics.
};

Toupony.MagicMissileWeapon.clean = function(gl) {
  Toupony.MagicMissileBullet.clean(gl);
  
  // TODO: Unload bullet trail graphics.
  // TODO: Unload satellite graphics.
};


Toupony.MagicMissileWeapon.prototype = {
  constructor: Toupony.MagicMissileWeapon,
  
  isaMagicMissileWeapon: true,
  
  /** 
   * The amount of time needed for the primary weapon to recharge.
   */
  COOL_DOWN_TIME: 30,
  
  /** 
   * The distance of the satellites from the player.
   */
  SAT_DISTANCE: 48,
  
  
  /** 
   * @inheritDoc Toupony.Weapon
   */
  update: function(player, context) {
    this._coolDown();
    this._moveSatellites(player);
  },
  
  
  /** 
   * Advances the cool-down timer on the weapon.
   */
  _coolDown: function() {
    if(this._timer > 0) {
      this._timer++;
    }
    if(this._timer == this.COOL_DOWN_TIME) {
      this._timer = 0;
    }
  },
  
  /** 
   * Moves the satellites relative to the player.
   * @param {Toupony.Player} player
   */
  _moveSatellites: function(player) {
    this._satAngle += TentaGL.TAU/60;
    
    var satAngle1 = this._satAngle
    var satAngle2 = this._satAngle + TentaGL.TAU/2;
    
    var xy = player.xy();
    // this._satellite1.xy([xy[0] + satDistance*Math.cos(satAngle1), xy[1] - satDistance*Math.sin(satAngle1)]);
    // this._satellite2.xy([xy[0] + satDistance*Math.cos(satAngle2), xy[1] - satDistance*Math.sin(satAngle2)]);
  },
  
  
  /** 
   * @inheritDoc Toupony.Weapon
   */
  fire: function(player, context) {
    var power = player.getStats().power();
    
    if(this._timer == 0) {
      this._timer = 1;
      
      this._firePlayer(player, power, context);
    }
    if(this._timer == Math.floor(this.COOL_DOWN_TIME * 1/3) && power >= 1.0) {
      // TODO: this._fireSatellite(this._satellite1, power, context);
    }
    if(this._timer == Math.floor(this.COOL_DOWN_TIME * 2/3) && power >= 3.0) {
      // TODO: this._fireSatellite(this._satellite2, power, context);
    }
  },
  
  /** Fires a bullet from the player. */
  _firePlayer: function(player, power, context) {
    var xy = player.xy();
    
    var bullet;
    if(power >= 2.0) {
      bullet = Toupony.MagicMissileBullet.createLarge(xy);
    }
    else {
      bullet = Toupony.MagicMissileBullet.createSmall(xy);
    }
    context.getPlayerBullets().add(bullet);
  },
  
  /** Fires a bullet from a satellite. */
  _fireSatellite: function(satellite, power, context) {
    var xy = satellite.xy();
    
    var bullet;
    if(power >= 4.0) {
      bullet = Toupony.MagicMissileBullet.createLarge(xy);
    }
    else {
      bullet = Toupony.MagicMissileBullet.createSmall(xy);
    }
    context.getPlayerBullets().add(bullet);
  },
  
  
  /** 
   * @inheritDoc Toupony.Weapon
   */
  render: function(gl) {
    // TODO: this._satellite1.render(gl);
    // TODO: this._satellite2.render(gl);
  }
  
};

Util.Inheritance.inherit(Toupony.MagicMissileWeapon, Toupony.Weapon);
Toupony.Cheats = {
  
  run: function(keyboard, context) {
    var player = context.getPlayer();
    var playerStats = player.getStats();
    
    // Set the player's power.
    if(keyboard.justPressed(KeyCode.NUM0)) {
      playerStats.power(0.0);
    }
    if(keyboard.justPressed(KeyCode.NUM1)) {
      playerStats.power(1.0);
    }
    if(keyboard.justPressed(KeyCode.NUM2)) {
      playerStats.power(2.0);
    }
    if(keyboard.justPressed(KeyCode.NUM3)) {
      playerStats.power(3.0);
    }
    if(keyboard.justPressed(KeyCode.NUM4)) {
      playerStats.power(4.0);
    }
    
  }
  
};
